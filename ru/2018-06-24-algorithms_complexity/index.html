<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swifty Finch"/><link rel="canonical" href="https://swiftyfinch.github.io/ru/2018-06-24-algorithms_complexity"/><meta name="twitter:url" content="https://swiftyfinch.github.io/ru/2018-06-24-algorithms_complexity"/><meta name="og:url" content="https://swiftyfinch.github.io/ru/2018-06-24-algorithms_complexity"/><title>Оценка алгоритмов для самых маленьких | Swifty Finch</title><meta name="twitter:title" content="Оценка алгоритмов для самых маленьких | Swifty Finch"/><meta name="og:title" content="Оценка алгоритмов для самых маленьких | Swifty Finch"/><meta name="description" content="Мой испытательный срок на новой работе подходит к концу, быстро время пролетело. У нас в компании принято рассказывать небольшой доклад по такому случаю. А так как я совсем недавно закончил курс Алгоритмы и структуры данных в ШАД, я решил почему бы не сделать доклад именно на эту тему. И конечно, почему бы не написать об этом!"/><meta name="twitter:description" content="Мой испытательный срок на новой работе подходит к концу, быстро время пролетело. У нас в компании принято рассказывать небольшой доклад по такому случаю. А так как я совсем недавно закончил курс Алгоритмы и структуры данных в ШАД, я решил почему бы не сделать доклад именно на эту тему. И конечно, почему бы не написать об этом!"/><meta name="og:description" content="Мой испытательный срок на новой работе подходит к концу, быстро время пролетело. У нас в компании принято рассказывать небольшой доклад по такому случаю. А так как я совсем недавно закончил курс Алгоритмы и структуры данных в ШАД, я решил почему бы не сделать доклад именно на эту тему. И конечно, почему бы не написать об этом!"/><!--Yandex.Metrika counter--><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

ym(62530267, "init", {
     clickmap:true,
     trackLinks:true,
     accurateTrackBounce:true
});</script><noscript><div><img src="https://mc.yandex.ru/watch/62530267" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!--/Yandex.Metrika counter--><meta name="yandex-verification" content="57c929529030b8fd"/><meta name="google-site-verification" content="u8NFg-rSs0ZM826TWcHCMQ90RRHRjEk9SpRSbYcB1rQ"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="/code.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180"/><link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"/><link rel="manifest" href="/site.webmanifest"/><meta name="twitter:image" content="https://swiftyfinch.github.io/site/avatar.png"/><meta name="og:image" content="https://swiftyfinch.github.io/site/avatar.png"/></head><body class="item-page"><header><div class="wrapper"><div class="facade"><a class="site-name" href="/ru"><img class="avatar" src="/site/avatar.png"/>Swifty Finch</a><div class="icons"><div><a class="icon" href="https://www.instagram.com/swiftyfinch"><img src="/site/networks/instagram_bw.png"/></a></div><div><a class="icon" href="https://twitter.com/swiftyfinch"><img src="/site/networks/twitter_bw.png"/></a></div><div><a class="icon" href="https://medium.com/@swiftyfinch"><img src="/site/networks/medium_bw.png"/></a></div><div><a class="icon" href="https://github.com/artFintch"><img src="/site/networks/github_bw.png"/></a></div><div><a class="icon" href="https://ekaterinburg.hh.ru/applicant/resumes/view?resume=227c8eb0ff013a445d0039ed1f395a436a494a"><img src="/site/networks/hh_bw.png"/></a></div><div><a class="icon" href="https://www.linkedin.com/in/vyacheslav-khorkov-92b65164"><img src="/site/networks/linkedin_bw.png"/></a></div><div><a class="icon" href="https://www.upwork.com/o/profiles/users/_~01379889e9ed58198c"><img src="/site/networks/upwork_bw.png"/></a></div></div><nav><a href="/en"><div>en</div></a></nav></div></div></header><div class="wrapper"><article><div class="content"><h1><p>Оценка алгоритмов для самых маленьких</p></h1><div class="tag-list"><a href="/tags/ru-swift"><div style="background-color: #6c99bb">swift</div></a><a href="/tags/ru-algorithms"><div style="background-color: #7daf9c">algorithms</div></a><a href="/tags/ru-story"><div style="background-color: #e86648">story</div></a></div><div class="date"><img class="date_icon" src="/reactions/calendar.svg"/><span>24.06.2018</span></div><div class="time_to_read"><img class="time_to_read_icon" src="/reactions/watch.svg"/><span class="time_to_read_text">7 мин</span></div><img src="/posts/2018-06-24-algorithms_complexity/head.jpg"/><p>Мой испытательный срок на новой работе подходит к концу, быстро время пролетело. У нас в компании принято рассказывать небольшой доклад по такому случаю. А так как я совсем недавно закончил курс <strong>Алгоритмы и структуры данных</strong> в <strong>ШАД</strong>, я решил почему бы не сделать доклад именно на эту тему. И конечно, почему бы не написать об этом!</p><h2 id="audience"><a href="#audience">Аудитория</a></h2><p>Статья подойдет абсолютно всем, но заинтересует лишь тех кто совсем не знаком с алгоритмами и структурами данных или недавно начал изучать язык программирования — <strong>Swift</strong>.</p><h2 id="short_info"><a href="#short_info">Краткое описание</a></h2><p>Это скорее обзорная статья, которая поможет вам слегка заглянуть в мир алгоритмов и структур. В начале я расскажу немного о теории оценки алгоритмов, затем немного практики. И в самом конце статьи немного <strong>о практическом применении</strong> всего этого или <strong>зачем это всё нужно?</strong></p><h2 id="estimate"><a href="#estimate">Оценка алгоритмов</a></h2><img src="/posts/2018-06-24-algorithms_complexity/donut.jpg"/><description>Big O Notation</description><p>Когда речь заходит об алгоритмах, встает вопрос об оценке их эффективности. Причем интересна оценка, которая не зависит от конфигурации конкретного устройства. Не важно на сколько быстрый у вас ноутбук или телефон, оценивается характер роста параметров алгоритма.</p><p>А что за параметры? Время и память. Причем именно дополнительная память, так как обычно размер входных данных не учитывается при оценке. Очень часто приходится жертвовать одним в пользу другого и такие ситуации называют <a href="https://ru.wikipedia.org/wiki/Компромисс_времени_и_памяти">trade-off</a>.</p><p>Итак, такую оценку принято производить с помощью асимптотического анализа, в котором эффективность оценивается в зависимости от размера входных данных. Для этого используется математическое обозначение <a href="https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое">Big O Notation</a>.</p><img src="/posts/2018-06-24-algorithms_complexity/plot.png"/><p>Выше на графике я постарался изобразить основные оценки:</p><ul><li><strong>O(1)</strong> константная сложность;</li><li><strong>O(log(n))</strong> логарифмическая сложность;</li><li><strong>O(n)</strong> линейная сложность;</li><li><strong>O(n²)</strong> квадратичная сложность.</li></ul><p>Также важно упомянуть об <strong>учетной или амортизированной оценке</strong>. Она применяется, когда невозможно или просто не выгодно оценивать стоимость операций одной оценкой. Стоимость может меняться от определенных условий, но иногда можно взять усредненную оценку по всем операциям. Такая оценка и будет называться учетной.</p><p>Это самый минимум теории по оценке и чуть ниже я покажу как это используется на практике.</p><h2 id="structs"><a href="#structs">Структуры данных</a></h2><p>Сразу хочу заметить, что <strong>Swift</strong> не богат на различные структуры данных. Их всего три: <strong>Array</strong>, <strong>Dictionary</strong> и <strong>Set</strong>. Все эти коллекции являются структурами <strong>struct</strong>, а в <strong>Swift</strong> все структуры являются <strong>Value</strong> <strong>Type</strong>. Это означает, что они передаются по значению, то есть копируются.</p><p>Для простоты я решил рассмотреть только массив, и этого будет достаточно для первого раза.</p><h2 id="array"><a href="#array">Array (Массив)</a></h2><p>Array — упорядоченная коллекций с произвольным доступом к элементам. Также, в других языках программирования, такую структуру называют вектором. Наверное, это самая популярная структура.</p><p>Рассмотрим базовые операции: доступ к конкретному элементу <strong>(subscript)</strong>, добавление нового элемента в конец <strong>(append)</strong> и удаление/добавление элемента <strong>(remove / insert)</strong>. Ниже я приведу сокращенные комментарии прямо из исходного кода.</p><h2 id="subscript"><a href="#subscript">Subscript</a></h2><p>Доступ к элементу работает за <strong>O(1)</strong>, но запись может вызвать операцию копирования всей коллекции и привести к сложности <strong>O(n)</strong>.</p><img src="/posts/2018-06-24-algorithms_complexity/access.png"/><p>Может у вас возник вопрос, а почему это запись вызывает копирование всего массива? Как я уже упомянул выше, массивы всегда передаются по значению или копируются. Но чтобы оптимизировать этот процесс в <strong>Swift</strong> есть механизм <strong>COW (Copy-on-write)</strong>.</p><img src="/posts/2018-06-24-algorithms_complexity/cow.jpg"/><p>И что же получается? Дело в том, что когда мы передаем массив в функцию или присваиваем в новую переменную он не копируется. Но если мы начинаем его изменять, то возможно две ситуации:</p><ul><li>Массив никуда не передавали и на него ссылается лишь одна переменная, тогда мы записываем по индексу за <strong>O(1)</strong>. Нет необходимости копировать весь массив;</li><li>Иначе, доступ к массиву осуществляется из нескольких мест. Тогда нам придется создать его копию и затем изменить именно её. Для всех остальных заинтересованных массив остается неизменным. Такая операция будет оцениваться как <strong>O(n)</strong>.</li></ul><h2 id="append"><a href="#append">Append</a></h2><p>Добавление элемента в конец работает за учетную стоимость <strong>O(1)</strong>. Почему учетную? Потому что если вся память выделенная под массив потрачена, то необходимо выделить новую память большего размера и затем перенести всю коллекцию на новое место, что приведет к сложности <strong>O(n)</strong>. Но, существуют специальные стратегии выделения памяти с запасом, которые гарантируют, что количество таких операций выделения памяти будет незначительным по сравнению с вставками в ранее выделенное место. Тогда получается что большинство операций будет выполняться за <strong>O(1)</strong>, но иногда придется копировать коллекцию за <strong>O(n)</strong>.</p><img src="/posts/2018-06-24-algorithms_complexity/add.png"/><h2 id="insert_remove"><a href="#insert_remove">Insert/Remove</a></h2><p>Операция добавления элемента работает за <strong>O(n)</strong>, так как при вставке потребуется сдвинуть каждый элемент после позиции вставки.</p><img src="/posts/2018-06-24-algorithms_complexity/insert.png"/><p>Операция удаления работает за <strong>O(n)</strong>, так как потребуется сдвинуть все элементы после позиции удаляемого элемента.</p><img src="/posts/2018-06-24-algorithms_complexity/remove.png"/><p>Однажды я проходил собеседование и мне нужно было написать алгоритм, который удалит все нули из массива за <strong>O(n)</strong>. И первое решение, которое пришло мне в голову было — написать <strong>while</strong> и воспользоваться операцией <strong>remove</strong>. Я думал вся хитрость в том, чтобы обойти <strong>for in</strong>. Такой алгоритм оценивался в <strong>O(n²)</strong>.</p><img src="/posts/2018-06-24-algorithms_complexity/kermit.gif"/><p>Я постарался написать обо всём очень кратко, поэтому если у вас остались вопросы, то смело задавайте их в комментариях.</p><h2 id="for_what"><a href="#for_what">И зачем мне всё это?!</a></h2><p>Пока я учился мне часто задавали этот вопрос. Давайте попробуем разобраться:</p><img src="/posts/2018-06-24-algorithms_complexity/interview.jpg"/><ul><li><strong>Собеседования</strong>. Да да, крупные компании очень любят давать простые задачи на эту тему. А в некоторых непростые. Или даже не задачи, а просто задавать вопросы приводящие к дискуссии. Как работает хеш функция? Какие худшие входные данные для быстрой сортировки и как её улучшить? Как искать минимальный элемент в массиве за константное время? А вы хотите работать в интересном для вас месте? Тогда будьте готовы, возможно вас это коснётся;</li></ul><ul><li><strong>Развитие</strong>. Я считаю каждый уважающий себя программист должен развиваться в области компьютерных наук. Иначе вам просто сложнее будет разбираться в деталях реализации, рассуждать на общие темы и писать что-то своё. Программирование это не только знание синтаксиса языка и стандартных библиотек. Это также алгоритмы и структуры данных, архитектура, различные утилиты, понимание как всё это устроенно на более низком уровне. Я сам долгое время старался избегать всего этого. И очень удивился, когда узнал что в одной крупной компании не важен опыт работы на конкретном языке. Они считают, что это может освоить любой студент за <strong>3 месяца работы в команде</strong>. <strong>Важна база</strong>.</li></ul><p>Я не стал делать это третьим пунктом, но лично <strong>мне нравится</strong> решать различные сложные задачи. Мне нравится ощущение того, что я сделал что-то сложное (почти невозможное для себя). Но, чтобы решать сложные задачи, нужно <strong>не бояться</strong> браться за то, что кажется нереально трудным для вас. Иначе как научиться? Про это я уже писал в статье про ШАД, иногда нужно <a href="https://translate.yandex.ru/?lang=en-ru&text=try%20hard">трайхардить</a>)</p><h2 id="results"><a href="#results">Выводы</a></h2><p>А выводы делайте сами, нужно это вам или нет? Вы можете присоединиться к обсуждению статьи на <a href="https://forum.swiftbook.ru/t/oczenka-algoritmov-dlya-samyh-malenkih-swift/6217/6">форуме</a>.</p><p>В ближайшее время я планирую решать различные алгоритмические задачи и готовиться к <a href="https://yandex.ru/promo/jobs/blitz/2018">Яндекс.Блиц 2018</a>. Не ради собеседования, а ради интереса) Я не так давно окончил курс в <strong>ШАД</strong> и мне хотелось бы применить свои знания в бою. Это не реклама! Так уж получается, что у <strong>Яндекса</strong> очень интересные события) Я работаю в другом месте.</p><p>На сколько мне известно, многие мобильные разработчики валятся на собеседованиях именно на математических или алгоритмических задачах. Но, этот навык можно покачать с помощью решения задач в различных сервисах.</p><p>Спустя какое-то время...</p><p>К сожалению, времени на организацию совместной подготовки не было, так как я стал преподавать курс по <strong>iOS</strong> разработке в <strong>Тинькофф Финтех школе</strong>. Да и на личную подготовку тоже) Но мне удалось взять третье место в <strong>Яндекс.Блиц 2018 по Мобильной разработке</strong>. Отборочный этап проходил на <strong>Swift</strong>, финал на <strong>C++</strong>. Попал в призы благодаря алгоритму <a href="https://ru.wikipedia.org/wiki/Алгоритм_Ахо_—_Корасик">Ахо-Корасик</a>.</p><img src="/posts/2018-06-24-algorithms_complexity/corasic.jpg"/><p>Всем спасибо за внимание! На этом всё! Ещё увидимся! но это не точно.</p></div></article></div><footer><a class="home" href="/ru" title="Go Home"><img src="/reactions/home.svg"/></a><p>© 2020. All rights reserved.</p><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p></footer></body></html>