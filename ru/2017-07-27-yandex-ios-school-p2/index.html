<!DOCTYPE html><html lang="ru"><head><meta charset="UTF-8"/><meta name="og:site_name" content="Swifty Finch"/><link rel="canonical" href="https://swiftyfinch.github.io/ru/2017-07-27-yandex-ios-school-p2"/><meta name="twitter:url" content="https://swiftyfinch.github.io/ru/2017-07-27-yandex-ios-school-p2"/><meta name="og:url" content="https://swiftyfinch.github.io/ru/2017-07-27-yandex-ios-school-p2"/><title>(ч.2) Яндекс Школа iOS | Swifty Finch</title><meta name="twitter:title" content="(ч.2) Яндекс Школа iOS | Swifty Finch"/><meta name="og:title" content="(ч.2) Яндекс Школа iOS | Swifty Finch"/><meta name="description" content="Вторая статья, является продолжением первой части. Неожиданно, первую часть прочитало довольно много человек. Вижу, что определенный интерес есть и я решил продолжить."/><meta name="twitter:description" content="Вторая статья, является продолжением первой части. Неожиданно, первую часть прочитало довольно много человек. Вижу, что определенный интерес есть и я решил продолжить."/><meta name="og:description" content="Вторая статья, является продолжением первой части. Неожиданно, первую часть прочитало довольно много человек. Вижу, что определенный интерес есть и я решил продолжить."/><!--Yandex.Metrika counter--><script type="text/javascript">(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

ym(62530267, "init", {
     clickmap:true,
     trackLinks:true,
     accurateTrackBounce:true
});</script><noscript><div><img src="https://mc.yandex.ru/watch/62530267" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!--/Yandex.Metrika counter--><meta name="yandex-verification" content="57c929529030b8fd"/><meta name="google-site-verification" content="u8NFg-rSs0ZM826TWcHCMQ90RRHRjEk9SpRSbYcB1rQ"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><link rel="stylesheet" href="/code.css" type="text/css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neucha:400,400italic,700|Abril+Fatface" type="text/css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito:400,400italic,700|Abril+Fatface" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180"/><link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32"/><link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16"/><link rel="manifest" href="/site.webmanifest"/><meta name="twitter:image" content="https://swiftyfinch.github.io/site/avatar.png"/><meta name="og:image" content="https://swiftyfinch.github.io/site/avatar.png"/></head><body class="item-page"><header><div class="wrapper"><div class="facade"><a class="site-name" href="/ru"><img class="avatar" src="/site/avatar.png"/>Swifty Finch</a><div class="icons"><div><a class="icon" href="https://www.instagram.com/swiftyfinch"><img src="/site/networks/instagram_bw.png"/></a></div><div><a class="icon" href="https://twitter.com/swiftyfinch"><img src="/site/networks/twitter_bw.png"/></a></div><div><a class="icon" href="https://medium.com/@swiftyfinch"><img src="/site/networks/medium_bw.png"/></a></div><div><a class="icon" href="https://github.com/artFintch"><img src="/site/networks/github_bw.png"/></a></div><div><a class="icon" href="https://ekaterinburg.hh.ru/applicant/resumes/view?resume=227c8eb0ff013a445d0039ed1f395a436a494a"><img src="/site/networks/hh_bw.png"/></a></div><div><a class="icon" href="https://www.linkedin.com/in/vyacheslav-khorkov-92b65164"><img src="/site/networks/linkedin_bw.png"/></a></div><div><a class="icon" href="https://www.upwork.com/o/profiles/users/_~01379889e9ed58198c"><img src="/site/networks/upwork_bw.png"/></a></div></div><nav><a href="/en"><div>en</div></a></nav></div></div></header><div class="wrapper"><article><div class="content"><h1>(ч.2) Яндекс Школа iOS</h1><ul class="tag-list"><li style="background-color: #efac32"><a href="/tags/ru-ios">ios</a></li><li style="background-color: #8381ba"><a href="/tags/ru-study">study</a></li><li style="background-color: #e86648"><a href="/tags/ru-story">story</a></li></ul><div class="date"><img class="date_icon" src="/reactions/calendar.svg"/><span>27.07.2017</span></div><div class="time_to_read"><img class="time_to_read_icon" src="/reactions/watch.svg"/><span class="time_to_read_text">10 мин</span></div><p><a href="https://academy.yandex.ru/events/mobdev/ekb-2017/"><img src="/posts/2017-07-27-yandex-ios-school-p2/yandex.png"/><description>Описание школы на сайте Яндекса.</description></a></p><p>Вторая статья, является продолжением <a href="/ru/2017-06-19-yandex-ios-school-p1/">первой части</a>. Неожиданно, первую часть прочитало довольно много человек. Вижу, что определенный интерес есть и я решил продолжить.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/bruce.gif"/><p>В этот раз расскажу об испытаниях при поступлении в <strong>Яндекс школу мобильной разработки iOS</strong>. Речь пойдет о платформе <a href="https://contest.yandex.ru/">Яндекс.Контест</a> и о задачах, которые необходимо было решить. Также немного расскажу об очном собеседовании.</p><h3>Для кого эта статья?</h3><p>Как и первая часть, в основном, для начинающих программистов, которым интересно обучение.</p><h3>Письмо и первые проблемы</h3><p>После заполнения анкеты я получил письмо, в котором было написано примерно следующее (я немного сократил):</p><p>Следующий шаг — решение первого тестового задания. Вот несколько вещей, которые полезно знать заранее:</p><ul><li>На решение дается <strong>9 часов</strong>. Начать можете в любой момент <strong>до 26 февраля включительно</strong>;</li><li>Первое тестовое задание проводится на платформе <a href="https://contest.yandex.ru/">Яндекс.Контест</a>. Чтобы познакомиться с системой, <strong>вы можете поучаствовать в пробном соревновании</strong>;</li><li>Если вы сделали несколько попыток по задаче, засчитана будет лучшая из них. По каждой задаче вы можете сделать не более <strong>100 попыток</strong>;</li><li>Проверка осуществляется автоматически, и несоблюдение форматов приведёт к тому, что ваше решение не будет засчитано. Обязательно <strong>соблюдайте формат ввода и вывода</strong>, описанный в задаче;</li><li>Все задачи — это задания по программированию. В них вам нужно <strong>отправить на проверку программу</strong>, решающую поставленную задачу; Для решения доступны следующие языки программирования: <strong>C</strong>, <strong>C++</strong>, <strong>PHP</strong>, <strong>Python 2</strong>, <strong>Python 3</strong>, <strong>C#</strong>, <strong>Java</strong>, <strong>Perl</strong>, <strong>Pascal</strong>, <strong>Go</strong>, <strong>Basic</strong>, <strong>Ruby</strong>, <strong>Rust</strong>, <strong>Delphi</strong>, <strong>Objective-C</strong>, <strong>Scala</strong>;</li><li>Через несколько секунд после отправки решения вы увидите результат запуска вашей программы на наших секретных тестах. Если вы видите вердикт <strong>ОК</strong>, значит все тесты пройдены. Если вы видите какой-то другой вердикт, значит ваша программа неверно работает на некоторых тестах. <a href="https://contest.yandex.ru/errors/">Подробнее о вердиктах</a>. Мы не показываем, на каком именно тесте ваша программа сработала неверно, но вы можете попробовать найти ошибку и отправить решение ещё раз;</li><li><strong>За каждый успешно пройденный тест вы получаете некоторое количество очков.</strong> Суммарное количество очков за решение отображается рядом с вердиктом проверки. Максимальное количество очков за задачу указано в скобках рядом с названием задачи в оглавлении.</li></ul><p>После того как я неторопливо прочитал письмо и просмотрел все ссылки в нем, я решил ознакомиться с платформой через пробное соревнование. И тут я вовремя заметил, что письмо пришло в <strong>22:46</strong> и это было <strong>воскресенье 26 февраля.</strong></p><img src="/posts/2017-07-27-yandex-ios-school-p2/mountain.png"/><p>В итоге у меня около часа на пробное соревнование и целая ночь впереди на настоящее. Хорошо, что на работе гибкий график.</p><h3>Пробное соревнование, а зачем?</h3><p>Все просто, в основном для того чтобы разобраться что <a href="https://contest.yandex.ru/">Яндекс.Контест</a> ожидает от вашего кода. Я планировал писать на <strong>Objective-C</strong> и мне потребовалось вспомнить как работают базовые функции ввода и вывода. А также, разобраться что код надо писать в <strong>main</strong>. Очевидно? Да, но в реальных проектах для iOS функция <strong>main</strong> создается автоматически и редко изменяется. А функцией <strong>scanf</strong> я наверное пользовался в последний раз <strong>лет 7 назад</strong>, когда учился.</p><p>Также в пробном соревновании можно посмотреть как выглядит текст задачи, ограничения по памяти и времени, формат ввода и вывода. Это все было в новинку для меня. Но сами задания очень простые, и даже может показаться, что после этого вы готовы решить что угодно.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/try.png"/><h3>Настоящее испытание</h3><p>На волне успеха в пробном соревновании я добрался до настоящего. Первая задача сразу же вернула меня в реальность <strong>Яндекса</strong>. В целом предлагалось решить четыре задачи. К сожалению, условия я не записывал и прошло довольно много времени. К тому же я проходил соревнование на рабочем ноутбуке, а затем при увольнении просто удалил учетную запись вместе со всеми решениями. Также из-за переезда потерялась тетрадь, в которой были наброски решений. В связи с этим описание заданий может быть очень неточным.</p><p>На сколько я помню во всех задачах были одинаковые ограничения:</p><ul><li>Ограничение по памяти: <strong>64 MB</strong></li><li>Ограничение по времени: <strong>2.0 секунды</strong></li></ul><h3>1. Простые числа.</h3><p>На вход передается натуральное число <strong>n, 1 ≥ n ≥ 10⁶</strong>. Необходимо вывести <strong>n-ое</strong> простое число.</p><p>Поиск простого числа распространенная задача, но здесь были свои нюансы. Самый простой способ найти простое число — перебрать интервал и проверял делимость на первые простые числа <strong>2, 3, 5, 7, 11</strong> и тд. Но здесь на вход может быть передано огромное число и нужен более разумный подход.</p><p>Самое первое что я нашел — <a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D1%88%D0%B5%D1%82%D0%BE_%D0%AD%D1%80%D0%B0%D1%82%D0%BE%D1%81%D1%84%D0%B5%D0%BD%D0%B0">Решето Эратосфена</a>. Готовых алгоритмов было достаточно <a href="https://habrahabr.ru/post/133037/">Habrahabr</a> или <a href="https://e-maxx.ru/algo/eratosthenes_sieve">MAXimal</a>. Но проблема в том, что непонятно какого размера нужно построить решето, чтобы в него попало <strong>n-ое</strong> простое.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/sieve.gif"/><p>Я продолжил поиск и со временем нашел решение на <a href="https://habrahabr.ru/post/124605/">Habrahabr</a>, правда опять на <strong>C++</strong>. Автор решения берет решето определенного размера, и затем увеличивает его если n-ое простое не попадает в него. Там же ему подсказывают, что есть примерная оценка интервала <a href="https://ru.wikipedia.org/wiki/%D0%93%D0%B8%D0%BF%D0%BE%D1%82%D0%B5%D0%B7%D0%B0_%D0%A0%D0%B8%D0%BC%D0%B0%D0%BD%D0%B0">Гипотеза Римена</a>.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/adventure.png"/><p>В итоге задача сводилась к тому, чтобы немного изменить готовое решение и протестировать локально в <strong>Xcode</strong>. Я решил не тратить время и не переписывать его на <strong>Objective-C</strong>. На эту задачу ушло около <strong>1.5</strong> часов и она прошла тесты на платформе с первой попытки. Начало неплохое)</p><p>На следующий день знакомый рассказал, что он просто нашел размер решета для числа <strong>10⁶</strong> и подставил его в алгоритм. В рамках задания можно было и так.</p><h3>2. Преобразование строк</h3><p>На вход передается строка. Необходимо ее трансформировать (сжать), а затем вывести. Например если вход: <strong>aaabb77daa8ccc</strong>, на выходе: <strong>3a2b27d2a83c</strong>.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/rle.png"/><p>На мой взгляд это самое простое задание, я написал его на <strong>Objective-C</strong>. Позже узнал как все это называется на <a href="https://en.wikipedia.org/wiki/Run-length_encoding">Wiki</a>. Я снова обрадовался, решение прошло все тесты с первого раза. После этого я уже немного расслабился, да и было ближе к <strong>3⁰⁰</strong>.</p><h3>3. Крестики и нолики</h3><p>Необходимо определить исход игры при идеальной игре каждого, если известен текущий расклад поля. Также известно, что было сделано <strong>1, 2 или 3</strong> хода. Одним ходом считать действие обоих игроков. На вход передается три строки с символами: <strong>X — крестик, O — нолик и # — пустая клетка</strong>. На выход нужно вывести: <strong>Won X</strong> — если победит крестик, <strong>Won O</strong> — если победит нолик или <strong>Draw</strong> — если ничья.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/xo.png"/><p>Решая эту задачу я исписал много листов бумаги, поиграл в реализацию от <strong>Google</strong>. Потом искал возможные исходы и алгоритмы и мне показалось, что еще чуть-чуть и я тут окончательно застряну и усну. Было около 4 ночи и я решил, что эту задачу лучше пропустить и вернуться к ней позже.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/gendalf.jpg"/><pre><code><span class="comment">// TODO: Вернуться к этой задаче позже</span>
</code></pre><p>Вернулся я уже ближе к 7 утра. Голова не работала, но я накидал примерные ситуации на <strong>Objective-C</strong>. Идея была в обработке шаблонных ситуаций. Например, если <strong>X</strong> в центре, а <strong>O</strong> не в диагональной клетке при идеальной игре <strong>X</strong> победит. Проверки на возможность создания ситуаций, в которых на следующем ходу можно победить (вилки). После нескольких попыток и исправлений я решил, что лучше сейчас уже не сделаю. В итоге я не набрал максимальный бал по этой задаче.</p><p>Возможно эту задачу можно решить используя минимакс или схожее дерево решений, но с ходу я не могу придумать как правильно взвешивать ситуации при идеальной игре каждого. Если кто-то знает, буду рад если поделитесь в комментариях.</p><h3>4. Графы</h3><p>На вход передается количество точек и ребер неориентированного графа. Затем перечисляются пары точек — ребра. И после этого идет список индексов ребер, которые необходимо удалять. Задача найти и вывести все компоненты связности после каждого удаленного ребра. Ребра могут повторяться.</p><p>Уже точно не помню лимиты на количество точек, ребер и индексов. Я почти уверен, что больше чем <strong>10⁶</strong>.</p><p>Последний раз я работал с графами в 2012 году, когда занимался созданием приложения для проектирования квартир на <strong>ActionScript 3.0</strong>. После реализации, очень интересно было просто разбивать большие квартиры на множество комнат.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/graphs.gif"/><description>Возможно сделаю частичный порт на Swift.</description><p>Для решения задачи я посмотрел как искать компоненты связности, нашел примеры реализации и применил их. Вроде ничего сложного. Для быстрого удаления ребер нужно просто использовать подходящие структуры данных. Я отправил решение на проверку и увидел примерно следующее: <strong>Time Limit: 2.056</strong>.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/pepe.jpg"/><p>После этого я переписывал решение еще десятки раз. Я слабо знаю <strong>C++</strong>, да и в графах не силен. Почитал о структурах данных, пытался переписать разными способами. Потом я понял, что если количество удаляемых ребер равно количеству всех ребер, то количество компонент связности будет равно количеству точек!) Быстро добавил проверку и отправил. Получил примерно <strong>Time Limit: 2.049</strong>.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/pepe2.jpg"/><p>К этому моменту я уже потратил пару часов на решение этой задачи и скорее всего уже было 6 утра. Я понял, что пора возвращаться к крестикам и ноликам... В конце концов я набрал на этой задаче примерно <strong>60–70%</strong> баллов. Я скопировал свой код, чтобы показать коллеге на работе.</p><p>Может показаться, что задача очень сложная. <strong>Но...</strong> меня ждал сюрприз. Коллега сказал, что в алгоритме все хорошо и особых проблем не видит. Хотя подметил, что совсем не обязательно выводить количество компонент связности после каждого удаления через <strong>printf</strong>. Особенно когда это может происходить по миллиону раз...</p><img src="/posts/2017-07-27-yandex-ios-school-p2/joe.gif"/><p>В целом задачи были не сложные. Вторая была очень простая. Первую и последнюю можно было решить даже если вы не знаете нужных алгоритмов. На просторах интернета хватает информации, все сводится к поиску и применению. Третья задача наверное была самой сложной для меня, к ней сложно найти почти готовое решение или даже идею решения. Ночью я измучился рисовать и разбирать большое количество ситуаций. Возможно днем я бы справился с ней быстрее. В целом я набрал максимальные баллы только по первым двум задачам. По двум остальным что-то около <strong>60–70%</strong>, на сколько я помню. В итоге этого было достаточно, чтобы попасть на очное собеседование.</p><h3>Очное собеседование</h3><p>Наверное спустя неделю мне пришло письмо. Необходимо было выбрать время и прийти в офис компании <strong>Яндекс</strong>. К этому собеседованию я почти не готовился, только просмотрел еще раз онлайн задачи. Мне наивно казалось, что будет скорее организационная часть и возможно устные технические вопросы и может по этим же задачам.</p><p>Когда я уже пришел в офис нужно было немного подождать. Пока я ожидал на ресепшен со мной рядом сидел парень. Я быстро догадался, что он тоже пришел поступать в школу. Было очень заметно, что он сильно нервничал)</p><img src="/posts/2017-07-27-yandex-ios-school-p2/interview.jpg"/><p>Собеседование было разбито на две части: техническая и организационная. На каждую часть отводилось по <strong>30 минут</strong>.</p><p>На технической части мне продиктовали задачу на преобразование строк. Сама задача была не сложная, но ее нужно было написать на существующем языке программирования (возможно ООП) <strong>на листке бумаги А4</strong>. После реализации меня попросили изменить решение без использования дополнительной памяти и определить сложность алгоритма. В целом задание мне показалось легким, я написал его на <strong>Objective-C</strong>.</p><p>В организационной части были различные вопросы об образовании, опыте разработки, желании обучаться в школе. Мне показалось, я как раз провалил эту часть. Дело в том, что у меня уже был хороший опыт и возникали сомнения в моей заинтересованности в стажировке после обучения. А основная цель, как я понимаю, привлечь и обучить будущих сотрудников.</p><h3>Почти конец</h3><p>В этой статье я описал лишь свои идеи решения задач. А где же код?! К сожалению, оригинальный код был утерян. Об этом я писал чуть выше. Но, я не поленился и решил еще раз все задачи на <strong>Swift</strong>. И уже собирался добавить решения в статью. И потом задумался, а какая разница как я решил эти задачи? Намного важнее как решите их вы, когда это потребуется!)</p><img src="/posts/2017-07-27-yandex-ios-school-p2/codewars.png"/><p>Поэтому я подготовил возможность повторить это испытание, любому кто захочет, на платформе <a href="https://www.codewars.com/collections/yandex-ios-school-entrance-exam">Codewars</a>. По ссылке я создал коллекцию из 4 испытаний под названием <strong>Yandex iOS School Entrance Exam</strong> для языка <strong>Swift</strong>. Все что вам нужно, зарегистрироваться (можно с <strong>Github</strong> аккаунта) и вы сможете решать эти задачи своим способом. Затем ваше решение должно пройти тесты, основанные на моем решении. Пишите, если будут проблемы. У меня пока желтый пояс по программированию.</p><h3>Заключение</h3><p>Какие выводы я сделал для себя?</p><ul><li>В <strong>Яндексе</strong> очень любят давать задачи на применение алгоритмов и структур данных. Не важно на каком языке вы пишите. Не важно какой у вас опыт. Нужно хорошо понимать как писать не только рабочий, но и оптимальный код. Могу порекомендовать статью: <a href="https://medium.com/@koss_lebedev/how-to-get-started-with-algorithms-to-be-a-better-developer-de617c7ba5b7">How to get started with algorithms to be a better developer</a>.</li><li>Вам необходимо знать как минимум один язык программирования (желательно ООП) на таком уровне, чтобы вы могли писать на нем почти с закрытыми глазами. Речь идет именно об языке и его стандартной библиотеке. Написание циклов, работа со строками, коллекциями, файлами, и тп. Это не включает знание конкретной платформы, инструментов и тп.</li><li>В онлайн испытании важно не написать идеальный алгоритм своими руками, а уметь определить тип задачи и подобрать необходимые средства для реализации за определенное время. Думаю я бы не смог сдать столько задач если бы писал все на <strong>Objective-C</strong> и не знал бы основ <strong>C/C++</strong>.</li><li>И самый простой вывод. К всему этому нужно готовиться. Мне кажется идеальных знаний просто не бывает. Тем более собеседования, соревнования и тп. — это всегда стресс.</li></ul><blockquote><p><strong>Идеал</strong> — цель, которая всегда меняется. Нельзя останавливаться.</p></blockquote><h3>В следующей части</h3><p>Я расскажу о самом обучении в школе, поделюсь впечатлением о домашних заданиях и лекциях. Было очень интересно) Скорее всего это будет последняя часть.</p><p>На этом пока все. И конечно, если статья была вам интересна, подписывайтесь в <a href="https://twitter.com/swiftyfinch">Twitter</a>. С помощью подписки вы узнаете <a href="/ru/2017-10-05-yandex-ios-school-p3">о следующей части</a>.</p><img src="/posts/2017-07-27-yandex-ios-school-p2/final.jpg"/></div></article></div><footer><a class="home" href="/ru" title="Go Home"><img src="/reactions/home.svg"/></a><p>© 2020. All rights reserved.</p><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p></footer></body></html>